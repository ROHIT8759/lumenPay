/**
 * ESCROW CONTRACT - Soroban Smart Contract
 * 
 * Handles collateral locking for loans:
 * - lock_collateral: Lock funds for loan collateral
 * - release_collateral: Release on successful repayment
 * - liquidate: Admin liquidation for defaulted loans
 * 
 * Events:
 * - CollateralLocked
 * - CollateralReleased
 * - Liquidated
 */

use soroban_sdk::{
    contract, contractimpl, contracttype, Env, Address, Symbol, token,
};

// ============================================================================
// DATA TYPES
// ============================================================================

#[contracttype]
#[derive(Clone)]
pub struct EscrowData {
    pub borrower: Address,
    pub lender: Address,           // Platform address or lender
    pub loan_id: u64,
    pub collateral_token: Address, // USDC or XLM token contract
    pub collateral_amount: i128,
    pub loan_amount: i128,
    pub created_at: u64,
    pub due_date: u64,
    pub is_locked: bool,
    pub is_liquidated: bool,
}

#[contracttype]
pub enum EscrowKey {
    Escrow(u64),      // loan_id -> EscrowData
    Admin,            // Admin address
    TotalLocked,      // Total collateral locked
}

// ============================================================================
// CONTRACT
// ============================================================================

#[contract]
pub struct EscrowContract;

#[contractimpl]
impl EscrowContract {
    /// Initialize the contract with an admin address
    pub fn initialize(env: Env, admin: Address) {
        if env.storage().persistent().has(&EscrowKey::Admin) {
            panic!("Contract already initialized");
        }
        env.storage().persistent().set(&EscrowKey::Admin, &admin);
        env.storage().persistent().set(&EscrowKey::TotalLocked, &0i128);
    }

    /// Lock collateral for a loan
    /// 
    /// # Arguments
    /// * `loan_id` - Unique loan identifier
    /// * `borrower` - Borrower's address
    /// * `lender` - Lender's address (can be platform)
    /// * `collateral_token` - Token contract address (USDC, XLM)
    /// * `collateral_amount` - Amount to lock
    /// * `loan_amount` - Loan amount being issued
    /// * `duration_seconds` - Loan duration in seconds
    pub fn lock_collateral(
        env: Env,
        loan_id: u64,
        borrower: Address,
        lender: Address,
        collateral_token: Address,
        collateral_amount: i128,
        loan_amount: i128,
        duration_seconds: u64,
    ) -> bool {
        // Require borrower authorization
        borrower.require_auth();

        // Validate amounts
        if collateral_amount <= 0 || loan_amount <= 0 {
            return false;
        }

        // Check if escrow already exists
        if env.storage().persistent().has(&EscrowKey::Escrow(loan_id)) {
            return false;
        }

        // Transfer collateral from borrower to contract
        let client = token::Client::new(&env, &collateral_token);
        client.transfer(&borrower, &env.current_contract_address(), &collateral_amount);

        // Create escrow record
        let escrow = EscrowData {
            borrower: borrower.clone(),
            lender: lender.clone(),
            loan_id,
            collateral_token,
            collateral_amount,
            loan_amount,
            created_at: env.ledger().timestamp(),
            due_date: env.ledger().timestamp() + duration_seconds,
            is_locked: true,
            is_liquidated: false,
        };

        // Store escrow
        env.storage().persistent().set(&EscrowKey::Escrow(loan_id), &escrow);

        // Update total locked
        let total: i128 = env.storage().persistent()
            .get(&EscrowKey::TotalLocked)
            .unwrap_or(0);
        env.storage().persistent().set(&EscrowKey::TotalLocked, &(total + collateral_amount));

        // Emit event
        env.events().publish(
            (Symbol::new(&env, "CollateralLocked"),),
            (loan_id, borrower, collateral_amount),
        );

        true
    }

    /// Release collateral back to borrower after successful repayment
    pub fn release_collateral(env: Env, loan_id: u64) -> bool {
        // Get escrow data
        let escrow: EscrowData = match env.storage().persistent().get(&EscrowKey::Escrow(loan_id)) {
            Some(e) => e,
            None => return false,
        };

        if !escrow.is_locked || escrow.is_liquidated {
            return false;
        }

        // Require lender authorization (to confirm loan is repaid)
        escrow.lender.require_auth();

        // Transfer collateral back to borrower
        let client = token::Client::new(&env, &escrow.collateral_token);
        client.transfer(
            &env.current_contract_address(),
            &escrow.borrower,
            &escrow.collateral_amount,
        );

        // Update escrow record
        let mut updated_escrow = escrow.clone();
        updated_escrow.is_locked = false;

        env.storage().persistent().set(&EscrowKey::Escrow(loan_id), &updated_escrow);

        // Update total locked
        let total: i128 = env.storage().persistent()
            .get(&EscrowKey::TotalLocked)
            .unwrap_or(0);
        env.storage().persistent().set(&EscrowKey::TotalLocked, &(total - escrow.collateral_amount));

        // Emit event
        env.events().publish(
            (Symbol::new(&env, "CollateralReleased"),),
            (loan_id, escrow.borrower, escrow.collateral_amount),
        );

        true
    }

    /// Liquidate collateral for defaulted loan
    /// Only admin can call this after loan is past due
    pub fn liquidate(env: Env, loan_id: u64) -> bool {
        // Get admin
        let admin: Address = env.storage().persistent()
            .get(&EscrowKey::Admin)
            .expect("Contract not initialized");

        // Require admin authorization
        admin.require_auth();

        // Get escrow data
        let escrow: EscrowData = match env.storage().persistent().get(&EscrowKey::Escrow(loan_id)) {
            Some(e) => e,
            None => return false,
        };

        if !escrow.is_locked || escrow.is_liquidated {
            return false;
        }

        // Check if loan is past due (for production, this would be enforced)
        // For demo, admin can liquidate anytime

        // Transfer collateral to lender (or platform treasury)
        let client = token::Client::new(&env, &escrow.collateral_token);
        client.transfer(
            &env.current_contract_address(),
            &escrow.lender,
            &escrow.collateral_amount,
        );

        // Update escrow record
        let mut updated_escrow = escrow.clone();
        updated_escrow.is_locked = false;
        updated_escrow.is_liquidated = true;

        env.storage().persistent().set(&EscrowKey::Escrow(loan_id), &updated_escrow);

        // Update total locked
        let total: i128 = env.storage().persistent()
            .get(&EscrowKey::TotalLocked)
            .unwrap_or(0);
        env.storage().persistent().set(&EscrowKey::TotalLocked, &(total - escrow.collateral_amount));

        // Emit event
        env.events().publish(
            (Symbol::new(&env, "Liquidated"),),
            (loan_id, escrow.borrower, escrow.collateral_amount),
        );

        true
    }

    /// Get escrow details
    pub fn get_escrow(env: Env, loan_id: u64) -> Option<EscrowData> {
        env.storage().persistent().get(&EscrowKey::Escrow(loan_id))
    }

    /// Check if loan is past due
    pub fn is_past_due(env: Env, loan_id: u64) -> bool {
        let escrow: EscrowData = match env.storage().persistent().get(&EscrowKey::Escrow(loan_id)) {
            Some(e) => e,
            None => return false,
        };

        escrow.is_locked && env.ledger().timestamp() > escrow.due_date
    }

    /// Get total collateral locked in contract
    pub fn get_total_locked(env: Env) -> i128 {
        env.storage().persistent()
            .get(&EscrowKey::TotalLocked)
            .unwrap_or(0)
    }

    /// Update admin (only current admin can do this)
    pub fn update_admin(env: Env, new_admin: Address) {
        let current_admin: Address = env.storage().persistent()
            .get(&EscrowKey::Admin)
            .expect("Contract not initialized");

        current_admin.require_auth();

        env.storage().persistent().set(&EscrowKey::Admin, &new_admin);
    }

    /// Get admin address
    pub fn get_admin(env: Env) -> Address {
        env.storage().persistent()
            .get(&EscrowKey::Admin)
            .expect("Contract not initialized")
    }
}

// ============================================================================
// TESTS
// ============================================================================

#[cfg(test)]
mod tests {
    use super::*;
    use soroban_sdk::testutils::{Address as _, Env as _};

    #[test]
    fn test_initialize() {
        let env = Env::default();
        let admin = Address::random(&env);
        
        let contract_id = env.register_contract(None, EscrowContract);
        let client = EscrowContractClient::new(&env, &contract_id);
        
        client.initialize(&admin);
        
        assert_eq!(client.get_admin(), admin);
        assert_eq!(client.get_total_locked(), 0);
    }

    #[test]
    fn test_lock_and_release() {
        // Test structure for lock_collateral and release_collateral
        // Would require setting up mock token contracts
    }
}
