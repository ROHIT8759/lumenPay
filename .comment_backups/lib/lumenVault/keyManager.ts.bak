import { Keypair } from '@stellar/stellar-sdk';

const KEY_LENGTH = 32;
const IV_LENGTH = 12; // AES-GCM recommended IV length
const SALT_LENGTH = 16;
const ITERATIONS = 100000;

export interface EncryptedKey {
    ciphertext: string;
    iv: string;
    salt: string;
}

export interface WalletData {
    publicKey: string;
    encryptedSecret: EncryptedKey;
    createdAt: number;
}

// Helper to convert hex strings to buffers and vice-versa
const toHex = (buffer: ArrayBuffer) => Array.from(new Uint8Array(buffer)).map(b => b.toString(16).padStart(2, '0')).join('');
const fromHex = (hex: string) => new Uint8Array(hex.match(/.{1,2}/g)!.map(byte => parseInt(byte, 16)));

async function deriveKey(passphrase: string, salt: Uint8Array): Promise<CryptoKey> {
    const enc = new TextEncoder();
    const keyMaterial = await window.crypto.subtle.importKey(
        "raw",
        enc.encode(passphrase),
        { name: "PBKDF2" },
        false,
        ["deriveKey"]
    );

    return window.crypto.subtle.deriveKey(
        {
            name: "PBKDF2",
            salt: salt,
            iterations: ITERATIONS,
            hash: "SHA-256"
        },
        keyMaterial,
        { name: "AES-GCM", length: 256 },
        false,
        ["encrypt", "decrypt"]
    );
}

export function generateKeypair(): Keypair {
    return Keypair.random();
}

export function importKeypair(secretKey: string): Keypair {
    try {
        return Keypair.fromSecret(secretKey);
    } catch (error) {
        throw new Error('Invalid secret key format');
    }
}

export function isValidSecretKey(secretKey: string): boolean {
    try {
        Keypair.fromSecret(secretKey);
        return true;
    } catch {
        return false;
    }
}

export function isValidPublicKey(publicKey: string): boolean {
    try {
        Keypair.fromPublicKey(publicKey);
        return true;
    } catch {
        return false;
    }
}

export async function encryptSecret(secretKey: string, passphrase: string): Promise<EncryptedKey> {
    const salt = window.crypto.getRandomValues(new Uint8Array(SALT_LENGTH));
    const iv = window.crypto.getRandomValues(new Uint8Array(IV_LENGTH));
    
    const key = await deriveKey(passphrase, salt);
    
    const enc = new TextEncoder();
    const encodedSecret = enc.encode(secretKey);
    
    const ciphertext = await window.crypto.subtle.encrypt(
        {
            name: "AES-GCM",
            iv: iv
        },
        key,
        encodedSecret
    );
    
    return {
        ciphertext: toHex(ciphertext),
        iv: toHex(iv),
        salt: toHex(salt)
    };
}

export async function decryptSecret(encrypted: EncryptedKey, passphrase: string): Promise<string> {
    try {
        const salt = fromHex(encrypted.salt);
        const iv = fromHex(encrypted.iv);
        const ciphertext = fromHex(encrypted.ciphertext);
        
        const key = await deriveKey(passphrase, salt);
        
        const decrypted = await window.crypto.subtle.decrypt(
            {
                name: "AES-GCM",
                iv: iv
            },
            key,
            ciphertext
        );
        
        const dec = new TextDecoder();
        return dec.decode(decrypted);
    } catch (error) {
        throw new Error('Failed to decrypt - incorrect passphrase or corrupted data');
    }
}

export async function createWalletData(keypair: Keypair, passphrase: string): Promise<WalletData> {
    const encryptedSecret = await encryptSecret(keypair.secret(), passphrase);

    return {
        publicKey: keypair.publicKey(),
        encryptedSecret,
        createdAt: Date.now(),
    };
}

export async function getKeypairFromWallet(wallet: WalletData, passphrase: string): Promise<Keypair> {
    const secretKey = await decryptSecret(wallet.encryptedSecret, passphrase);
    return Keypair.fromSecret(secretKey);
}

export async function exportSecret(wallet: WalletData, passphrase: string): Promise<string> {
    return await decryptSecret(wallet.encryptedSecret, passphrase);
}

export function generateMnemonic(): string {
    const keypair = generateKeypair();
    return keypair.secret();
}
